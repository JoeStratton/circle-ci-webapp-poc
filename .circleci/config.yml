version: 2.1

# Orbs for enhanced functionality
orbs:
  aws-cli: circleci/aws-cli@5.4.1
  docker: circleci/docker@3.0.0
  python: circleci/python@3.2.0

# Executors define the execution environment
executors:
  python-executor:
    docker:
      - image: cimg/python:3.11
    working_directory: ~/project
    
  docker-executor:
    docker:
      - image: cimg/base:stable
    working_directory: ~/project
    
  terraform-docker-executor:
    docker:
      - image: hashicorp/terraform:1.13.1
    working_directory: ~/project

  terraform-executor:
    docker:
      - image: hashicorp/terraform:1.13.1
    working_directory: ~/project

# Commands for reusable logic
commands:
  setup-dependencies:
    description: "Install Python dependencies and setup environment"
    steps:
      - checkout
      - python/install-packages:
          pkg-manager: pip
          pip-dependency-file: app/requirements.txt
      - run:
          name: Install additional test dependencies
          command: |
            pip install pytest-xdist pytest-mock bandit flake8
            
  run-tests-with-db:
    description: "Run tests with PostgreSQL database and collect results for CircleCI"
    steps:
      - run:
          name: Install dockerize for database wait
          command: |
            wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz
            sudo tar -C /usr/local/bin -xzvf dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz
            rm dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz
          environment:
            DOCKERIZE_VERSION: v0.6.1
      - run:
          name: Wait for database
          command: dockerize -wait tcp://localhost:5432 -timeout 1m
      - run:
          name: Run integration tests with dedicated script
          command: |
            export DATABASE_URL="postgresql://testuser:testpass@localhost:5432/testdb"
            ./scripts/test-integration.sh
      - store_test_results:
          path: test-results

  security-scan:
    description: "Run security scans and compliance checks"
    steps:
      - run:
          name: Security scan with bandit
          command: |
            mkdir -p test-results
            bandit -r app/app.py -f json -o security-report.json || true
            bandit -r app/app.py -f txt
            # Generate JUnit XML for test results
            bandit -r app/app.py -f json -o test-results/security-tests.xml || true
      - store_test_results:
          path: test-results
      - store_artifacts:
          path: security-report.json
          destination: security-report.json

  configure-oidc-auth:
    description: "Configure AWS CLI with OIDC authentication"
    steps:
      - aws-cli/setup:
          region: $AWS_REGION
      - run:
          name: Configure OIDC Authentication
          command: |
            aws configure set region $AWS_REGION
            echo $CIRCLE_OIDC_TOKEN > /tmp/oidc_token
            export AWS_WEB_IDENTITY_TOKEN_FILE=/tmp/oidc_token
            export AWS_ROLE_ARN=$AWS_ROLE_ARN

  terraform-format-check:
    description: "Check Terraform formatting"
    steps:
      - checkout
      - run:
          name: Terraform format check
          command: |
            cd terraform
            terraform fmt -check -recursive

  terraform-validate-config:
    description: "Validate Terraform configuration"
    steps:
      - checkout
      - run:
          name: Terraform validate
          command: |
            cd terraform
            # Use local backend for validation to avoid AWS credential issues
            terraform init -backend=false
            terraform validate

  terraform-plan-with-auth:
    description: "Run Terraform plan with OIDC authentication and store artifacts"
    steps:
      - checkout
      - configure-oidc-auth
      - run:
          name: Terraform plan
          command: |
            # Configure AWS CLI with OIDC token
            export AWS_WEB_IDENTITY_TOKEN_FILE=/tmp/oidc_token
            export AWS_ROLE_ARN=$AWS_ROLE_ARN
            
            cd terraform
            terraform init
            terraform plan \
              -var="circleci_organization_id=$CIRCLECI_ORGANIZATION_ID" \
              -var="circleci_project_id=$CIRCLECI_PROJECT_ID" \
              -var="database_username=$DB_USERNAME" \
              -var="database_password=$DB_PASSWORD" \
              -out=tfplan
      - run:
          name: Generate human-readable plan output
          command: |
            # Configure AWS CLI with OIDC token
            export AWS_WEB_IDENTITY_TOKEN_FILE=/tmp/oidc_token
            export AWS_ROLE_ARN=$AWS_ROLE_ARN
            
            cd terraform
            terraform show -no-color tfplan > plan-output.txt
      - store_artifacts:
          path: terraform/tfplan
          destination: terraform-plan
      - store_artifacts:
          path: terraform/plan-output.txt
          destination: terraform-plan-output
      - persist_to_workspace:
          root: .
          paths:
            - terraform/tfplan
            - terraform/plan-output.txt

  terraform-apply-with-auth:
    description: "Run Terraform apply with OIDC authentication and release updates"
    steps:
      - checkout
      - attach_workspace:
          at: .
      - configure-oidc-auth
      - run:
          name: Start release plan
          command: circleci run release plan terraform-deploy --environment-name=dev --component-name=infrastructure --target-version=${CIRCLE_SHA1}
      - run:
          name: Terraform apply
          command: |
            export AWS_WEB_IDENTITY_TOKEN_FILE=/tmp/oidc_token
            export AWS_ROLE_ARN=$AWS_ROLE_ARN
            
            cd terraform
            terraform init
            terraform apply tfplan

  push-to-ecr-with-auth:
    description: "Push Docker image to ECR with OIDC authentication"
    steps:
      - checkout
      - attach_workspace:
          at: .
      - setup_remote_docker
      - configure-oidc-auth
      - run:
          name: Load and tag Docker image
          command: |
            docker load -i docker-image.tar
            
            # Configure AWS CLI with OIDC token
            export AWS_WEB_IDENTITY_TOKEN_FILE=/tmp/oidc_token
            export AWS_ROLE_ARN=$AWS_ROLE_ARN
            
            # Get ECR repository URL
            ECR_URI=$(aws ecr describe-repositories --repository-names circle-ci-webapp-poc-app --query 'repositories[0].repositoryUri' --output text)
            
            # Tag image for ECR
            docker tag circleci-demo-app:${CIRCLE_SHA1} $ECR_URI:${CIRCLE_SHA1}
            docker tag circleci-demo-app:${CIRCLE_SHA1} $ECR_URI:latest
      - run:
          name: Login to ECR and push image
          command: |
            # Configure AWS CLI with OIDC token
            export AWS_WEB_IDENTITY_TOKEN_FILE=/tmp/oidc_token
            export AWS_ROLE_ARN=$AWS_ROLE_ARN
            
            # Login to ECR
            aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $(aws ecr describe-repositories --repository-names circle-ci-webapp-poc-app --query 'repositories[0].repositoryUri' --output text | cut -d'/' -f1)
            
            # Push images
            ECR_URI=$(aws ecr describe-repositories --repository-names circle-ci-webapp-poc-app --query 'repositories[0].repositoryUri' --output text)
            docker push $ECR_URI:${CIRCLE_SHA1}
            docker push $ECR_URI:latest
            
            echo "✅ Images pushed to ECR successfully"
      - run:
          name: Create deployment artifact
          command: |
            mkdir -p artifacts
            cat > artifacts/deployment-info.json \<< EOF
            {
              "commit_sha": "${CIRCLE_SHA1}",
              "branch": "${CIRCLE_BRANCH}",
              "build_num": "${CIRCLE_BUILD_NUM}",
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "image_tag": "${CIRCLE_SHA1}",
              "environment": "production"
            }
            EOF
      - store_artifacts:
          path: artifacts
          destination: deployment-artifacts

  deploy-to-ecs-with-auth:
    description: "Deploy to ECS with OIDC authentication"
    steps:
      - checkout
      - configure-oidc-auth
      - run:
          name: Update ECS service with new image
          command: |
            export AWS_WEB_IDENTITY_TOKEN_FILE=/tmp/oidc_token
            export AWS_ROLE_ARN=$AWS_ROLE_ARN
            
            ECR_URI=$(aws ecr describe-repositories --repository-names circle-ci-webapp-poc-app --query 'repositories[0].repositoryUri' --output text)
            ECS_CLUSTER="circle-ci-webapp-poc-cluster"
            ECS_SERVICE="circle-ci-webapp-poc-service"
            TASK_FAMILY="circle-ci-webapp-poc-task"
            
            # Get current task definition and check if image needs updating
            TASK_DEF=$(aws ecs describe-task-definition --task-definition $TASK_FAMILY --query taskDefinition)
            CURRENT_IMAGE=$(echo $TASK_DEF | jq -r '.containerDefinitions[0].image')
            NEW_IMAGE="$ECR_URI:$CIRCLE_SHA1"
            
            if [ "$CURRENT_IMAGE" = "$NEW_IMAGE" ]; then
              echo "Image $NEW_IMAGE is already deployed. Skipping ECS update."
            else
              echo "Updating from $CURRENT_IMAGE to $NEW_IMAGE"
              NEW_TASK_DEF=$(echo $TASK_DEF | jq --arg IMAGE_URI "$NEW_IMAGE" '.containerDefinitions[0].image = $IMAGE_URI | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
              NEW_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json "$NEW_TASK_DEF" --query taskDefinition.taskDefinitionArn --output text)
              aws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE --task-definition $NEW_TASK_DEF_ARN
              aws ecs wait services-stable --cluster $ECS_CLUSTER --services $ECS_SERVICE
            fi
      - run:
          name: Update deploy status
          command: |
            if [ $? -eq 0 ]; then
              circleci run release update terraform-deploy --status=success || true
            else
              circleci run release update terraform-deploy --status=fail || true
            fi

# Job definitions
jobs:
  # Code quality and linting
  lint-and-format:
    executor: python-executor
    steps:
      - setup-dependencies
      - run:
          name: Run linting checks
          command: |
            echo "Running code quality checks..."
            flake8 app/app.py --max-line-length=120 --statistics
            python -m py_compile app/app.py
            echo "✅ Code quality checks passed"
      - run:
          name: Check requirements
          command: |
            pip check
            echo "✅ Dependencies are compatible"

  # Unit tests without database
  unit-tests:
    executor: python-executor
    steps:
      - setup-dependencies
      - run:
          name: Run unit tests with dedicated script
          command: |
            ./scripts/test-unit.sh
      - store_test_results:
          path: test-results

  # Integration tests with PostgreSQL sidecar 
  integration-tests:
    executor: python-executor
    docker:
      - image: cimg/python:3.11
        environment:
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/testdb
          FLASK_ENV: testing
      - image: cimg/postgres:13.8
        environment:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
    steps:
      - setup-dependencies
      - run-tests-with-db
      - security-scan

  # Build and test custom Docker image 
  build-and-test-image:
    executor: docker-executor
    steps:
      - checkout
      - setup_remote_docker
      - run:
          name: Build custom Docker image
          command: |
            echo "Building custom Docker image for linux/amd64..."
            docker build --platform linux/amd64 -f docker/Dockerfile -t circleci-demo-app:${CIRCLE_SHA1} .
            docker tag circleci-demo-app:${CIRCLE_SHA1} circleci-demo-app:latest
            echo "✅ Docker image built successfully"
      - run:
          name: Test Docker image with container health checks
          command: |
            echo "Testing Docker image functionality..."
            
            # Test image with SQLite (no external dependencies for basic test)
            docker run -d --name test-app \
              -e DATABASE_URL=sqlite:///test.db \
              -e FLASK_ENV=testing \
              -p 5000:5000 \
              circleci-demo-app:${CIRCLE_SHA1}
            
            # Wait for application startup
            sleep 20
            
            # Test health endpoint
            docker exec test-app curl -f http://localhost:5000/health || exit 1
            
            # Test API endpoint
            docker exec test-app curl -f http://localhost:5000/api/health || exit 1
            
            echo "✅ Docker image tests passed"
            
            # Cleanup
            docker stop test-app && docker rm test-app
      - run:
          name: Save Docker image for workspace
          command: |
            docker save circleci-demo-app:${CIRCLE_SHA1} -o docker-image.tar
      - persist_to_workspace:
          root: .
          paths:
            - docker-image.tar

  # Container testing with dgoss (requirement #3)
  container-tests:
    executor: python-executor
    steps:
      - setup-dependencies
      - attach_workspace:
          at: .
      - setup_remote_docker
      - run:
          name: Load Docker image from workspace
          command: |
            docker load -i docker-image.tar
      - run:
          name: Run container tests with dedicated script
          command: |
            ./scripts/test-container.sh
      - store_test_results:
          path: test-results

  # Terraform validation jobs
  terraform-fmt:
    executor: terraform-executor
    steps:
      - terraform-format-check

  terraform-validate:
    executor: terraform-executor
    steps:
      - terraform-validate-config

  # Production deployment jobs
  push-to-ecr:
    executor: docker-executor
    steps:
      - push-to-ecr-with-auth

  terraform-plan:
    executor: terraform-docker-executor
    steps:
      - terraform-plan-with-auth

  terraform-apply:
    executor: terraform-docker-executor
    steps:
      - terraform-apply-with-auth

  deploy-to-ecs:
    executor: python-executor
    steps:
      - deploy-to-ecs-with-auth

# Workflows define job orchestration with branch-based conditions
workflows:
  version: 2
  build-test-deploy:
    jobs:
      # Phase 1: Code Quality and Testing (runs on all branches in parallel)
      - lint-and-format
      - unit-tests
      - integration-tests
      - terraform-fmt
      - terraform-validate
  
      # Phase 2: Build and Test Docker Image (runs on all branches)
      - build-and-test-image
      
      # Phase 3: Container Testing (runs on all branches, requires previous phases)
      - container-tests:
          requires:
            - lint-and-format
            - unit-tests
            - integration-tests
            - build-and-test-image
      
      # Phase 5: Production Deployment (MAIN BRANCH ONLY)
      - push-to-ecr:
          context: aws-production
          requires:
            - container-tests
            - terraform-fmt
            - terraform-validate
          filters:
            branches:
              only: main
      
      - terraform-plan:
          context: aws-production
          requires:
            - container-tests
            - terraform-fmt
            - terraform-validate
          filters:
            branches:
              only: main
      
      - hold-apply:
          type: approval
          requires:
            - push-to-ecr
            - terraform-plan
          filters:
            branches:
              only: main
      
      - terraform-apply:
          context: aws-production
          requires:
            - hold-apply
          filters:
            branches:
              only: main
      
      - deploy-to-ecs:
          context: aws-production
          requires:
            - terraform-apply
          filters:
            branches:
              only: main